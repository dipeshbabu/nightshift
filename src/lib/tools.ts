import { join, relative, delimiter } from "path";
import { mkdirSync, existsSync, chmodSync, symlinkSync, unlinkSync, writeFileSync } from "fs";
import type { Platform, BinaryMapping } from "./types";
import { OPENCODE_VERSION, UV_VERSION, RIPGREP_VERSION, RUBY_VERSION, CMAKE_VERSION } from "./constants";
import { download, extract } from "./download";
import { buildUvEnv } from "./env";

/**
 * Write a minimal pkg-config shim into prefix/bin so that Rugged's extconf.rb
 * can locate libgit2 linker flags without a real pkg-config installation.
 *
 * The shim handles the three invocations Rugged actually uses:
 *   pkg-config --version
 *   pkg-config --exists <pkg>
 *   pkg-config --libs --static <file.pc>
 */
function installPkgConfigShim(prefix: string): void {
  const binDir = join(prefix, "bin");
  mkdirSync(binDir, { recursive: true });
  const shimPath = join(binDir, "pkg-config");

  const script = `#!/bin/sh
# Minimal pkg-config shim generated by nightshift install.
# Only supports the subset of flags that Rugged/extconf.rb uses.

if [ "$1" = "--version" ]; then
  echo "0.29.2"
  exit 0
fi

if [ "$1" = "--exists" ]; then
  exit 0
fi

# --libs [--static] <file.pc>
# Collect the last argument that ends in .pc
PC_FILE=""
for arg in "$@"; do
  case "$arg" in
    *.pc) PC_FILE="$arg" ;;
  esac
done

if [ -z "$PC_FILE" ] || [ ! -f "$PC_FILE" ]; then
  exit 1
fi

# Resolve variables defined in the .pc file (prefix, libdir, includedir, etc.)
# then print Libs + Libs.private combined.
awk '
  /^[a-zA-Z_][a-zA-Z0-9_]*=/ {
    split($0, kv, "=")
    key = kv[1]
    val = substr($0, length(key) + 2)
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
    vars[key] = val
    next
  }
  function expand(s,   k, v, pat, pos) {
    for (k in vars) {
      v = vars[k]
      pat = "\${" k "}"
      while ((pos = index(s, pat)) > 0) {
        s = substr(s, 1, pos - 1) v substr(s, pos + length(pat))
      }
    }
    return s
  }
  /^Libs:/ {
    libs = expand(substr($0, length("Libs:") + 1))
  }
  /^Libs\\.private:/ {
    libs_priv = expand(substr($0, length("Libs.private:") + 1))
  }
  END {
    printf "%s %s\\n", libs, libs_priv
  }
' "$PC_FILE"
`;

  writeFileSync(shimPath, script);
  chmodSync(shimPath, 0o755);
}

export function opencodeUrl(p: Platform): { url: string; extractedBinary: string } {
  const os = p.os === "darwin" ? "darwin" : "linux";
  const arch = p.arch === "aarch64" ? "arm64" : "x64";
  const ext = p.os === "darwin" ? "zip" : "tar.gz";
  return {
    url: `https://github.com/anomalyco/opencode/releases/download/${OPENCODE_VERSION}/opencode-${os}-${arch}.${ext}`,
    extractedBinary: "opencode",
  };
}

export function uvUrl(p: Platform): { url: string; extractedBinary: string } {
  const triple =
    p.os === "darwin"
      ? `${p.arch}-apple-darwin`
      : `${p.arch}-unknown-linux-gnu`;
  return {
    url: `https://github.com/astral-sh/uv/releases/download/${UV_VERSION}/uv-${triple}.tar.gz`,
    extractedBinary: `uv-${triple}/uv`,
  };
}

export function ripgrepUrl(p: Platform): { url: string; extractedBinary: string } {
  const triple =
    p.os === "darwin"
      ? `${p.arch}-apple-darwin`
      : p.arch === "x86_64"
        ? `x86_64-unknown-linux-musl`
        : `aarch64-unknown-linux-gnu`;
  return {
    url: `https://github.com/BurntSushi/ripgrep/releases/download/${RIPGREP_VERSION}/ripgrep-${RIPGREP_VERSION}-${triple}.tar.gz`,
    extractedBinary: `ripgrep-${RIPGREP_VERSION}-${triple}/rg`,
  };
}

export async function installTool(
  name: string,
  url: string,
  prefix: string,
  binaryMappings: BinaryMapping[],
): Promise<void> {
  console.log(`\nInstalling ${name}...`);
  const toolsDir = join(prefix, "tools", name);
  const binDir = join(prefix, "bin");
  mkdirSync(toolsDir, { recursive: true });
  mkdirSync(binDir, { recursive: true });

  const archiveName = url.split("/").pop()!;
  const archivePath = join(prefix, "tools", archiveName);

  await download(url, archivePath);
  await extract(archivePath, toolsDir);

  // Create symlinks
  for (const mapping of binaryMappings) {
    const linkPath = join(binDir, mapping.linkName);
    const targetAbsolute = join(toolsDir, mapping.target);

    if (!existsSync(targetAbsolute)) {
      console.warn(`  Warning: binary not found at ${targetAbsolute}`);
      continue;
    }

    // Ensure executable
    chmodSync(targetAbsolute, 0o755);

    // Create relative symlink
    const relTarget = relative(binDir, targetAbsolute);
    if (existsSync(linkPath)) {
      const { unlinkSync } = await import("fs");
      unlinkSync(linkPath);
    }
    symlinkSync(relTarget, linkPath);
    console.log(`  Linked ${mapping.linkName} → ${relTarget}`);
  }

  // Clean up archive
  const { unlinkSync } = await import("fs");
  unlinkSync(archivePath);
}

export function cmakeUrl(p: Platform): { url: string; extractedBinary: string } {
  const base = `https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}`;
  if (p.os === "darwin") {
    return {
      url: `${base}/cmake-${CMAKE_VERSION}-macos-universal.tar.gz`,
      extractedBinary: `cmake-${CMAKE_VERSION}-macos-universal/CMake.app/Contents/bin/cmake`,
    };
  }
  const arch = p.arch === "aarch64" ? "aarch64" : "x86_64";
  return {
    url: `${base}/cmake-${CMAKE_VERSION}-linux-${arch}.tar.gz`,
    extractedBinary: `cmake-${CMAKE_VERSION}-linux-${arch}/bin/cmake`,
  };
}

export function portableRubyUrl(p: Platform): { url: string; extractedBinary: string } {
  const base = `https://github.com/Homebrew/homebrew-portable-ruby/releases/download/${RUBY_VERSION}`;
  const asset =
    p.os === "darwin" && p.arch === "aarch64"
      ? `portable-ruby-${RUBY_VERSION}.arm64_big_sur.bottle.tar.gz`
      : p.os === "darwin" && p.arch === "x86_64"
        ? `portable-ruby-${RUBY_VERSION}.el_capitan.bottle.tar.gz`
        : p.os === "linux" && p.arch === "x86_64"
          ? `portable-ruby-${RUBY_VERSION}.x86_64_linux.bottle.tar.gz`
          : `portable-ruby-${RUBY_VERSION}.arm64_linux.bottle.tar.gz`;
  return {
    url: `${base}/${asset}`,
    extractedBinary: `portable-ruby/${RUBY_VERSION}/bin/ruby`,
  };
}

export async function installRubyAndGollum(prefix: string): Promise<void> {
  const platform = (await import("./platform")).detectPlatform();
  const ruby = portableRubyUrl(platform);

  await installTool("ruby", ruby.url, prefix, [
    { linkName: "ruby", target: `portable-ruby/${RUBY_VERSION}/bin/ruby` },
    { linkName: "gem", target: `portable-ruby/${RUBY_VERSION}/bin/gem` },
  ]);

  // cmake is required to compile Rugged's native extension (libgit2).
  const cmake = cmakeUrl(platform);
  await installTool("cmake", cmake.url, prefix, [
    { linkName: "cmake", target: cmake.extractedBinary },
  ]);

  // Rugged (gollum dependency) requires pkg-config to build native extensions.
  // Install a self-contained shim so we don't need brew/apt-get.
  installPkgConfigShim(prefix);

  console.log("\nInstalling gollum gem...");
  const gemBin = join(prefix, "bin", "gem");
  const gemHome = join(prefix, "gems");
  mkdirSync(gemHome, { recursive: true });

  // Disable HTTPS in libgit2 (built by Rugged's native extension).
  // OpenSSL 3 (Ubuntu 22.04+) removed the MD4 symbol that Rugged links against,
  // causing "undefined symbol: MD4" at runtime on Linux. Gollum only reads local
  // repos so HTTPS support is unnecessary.
  const proc = Bun.spawn(
    [gemBin, "install", "gollum"],
    {
      stdout: "inherit",
      stderr: "inherit",
      env: {
        ...process.env,
        GEM_HOME: gemHome,
        CMAKE_FLAGS: "-DUSE_HTTPS=OFF",
        PATH: `${join(prefix, "bin")}${delimiter}${process.env.PATH}`,
      },
    },
  );
  const exitCode = await proc.exited;
  if (exitCode !== 0) throw new Error(`gem install gollum failed (${exitCode})`);

  // Symlink gollum binary from gems/bin into prefix/bin
  const gollumSrc = join(gemHome, "bin", "gollum");
  const gollumLink = join(prefix, "bin", "gollum");
  if (existsSync(gollumSrc)) {
    if (existsSync(gollumLink)) {
      unlinkSync(gollumLink);
    }
    const relTarget = relative(join(prefix, "bin"), gollumSrc);
    symlinkSync(relTarget, gollumLink);
    console.log(`  Linked gollum → ${relTarget}`);
  } else {
    console.warn(`  Warning: gollum binary not found at ${gollumSrc}`);
  }
  console.log("  gollum installed successfully.");
}

/**
 * Check which required binaries are missing from a prefix's bin directory.
 * Returns the list of missing binary names.
 */
export function checkPrefixTools(prefix: string): string[] {
  const binDir = join(prefix, "bin");
  const required = ["opencode", "uv", "rg", "ruby", "gem", "gollum", "cmake"];
  return required.filter((bin) => !existsSync(join(binDir, bin)));
}

export interface EnsurePrefixToolsOptions {
  /** Override the gollum installer (used by tests to avoid network calls). */
  installGollum?: (prefix: string) => Promise<void>;
}

/**
 * Ensure a prefix has all tools required by the current nightshift version.
 * Automatically installs missing tools when possible, allowing older prefixes
 * to be transparently upgraded (e.g. adding gollum introduced in v0.1.4).
 */
export async function ensurePrefixTools(
  prefix: string,
  opts?: EnsurePrefixToolsOptions,
): Promise<void> {
  const missing = checkPrefixTools(prefix);
  if (missing.length === 0) return;

  // Core tools cannot be auto-installed — the user must re-run install.
  const coreTools = ["opencode", "uv", "rg"];
  const missingCore = coreTools.filter((t) => missing.includes(t));
  if (missingCore.length > 0) {
    throw new Error(
      `Core tools missing from prefix: ${missingCore.join(", ")}. Run 'nightshift install --prefix <path>' to create a fresh prefix.`,
    );
  }

  // Ruby / gollum can be installed on the fly.
  const gollumTools = ["ruby", "gem", "gollum", "cmake"];
  if (gollumTools.some((t) => missing.includes(t))) {
    console.log(`Upgrading prefix: installing missing tools (${missing.join(", ")})...`);
    const installer = opts?.installGollum ?? installRubyAndGollum;
    await installer(prefix);
  }

  // Verify everything is in place after install.
  const stillMissing = checkPrefixTools(prefix);
  if (stillMissing.length > 0) {
    throw new Error(
      `Prefix is still missing tools after upgrade: ${stillMissing.join(", ")}. ` +
      `Run 'nightshift install --prefix <path>' to create a fresh prefix.`,
    );
  }

  console.log("Prefix upgrade complete.");
}

export async function installUvTools(prefix: string): Promise<void> {
  console.log(`\nInstalling uv tools...`);
  const uv = join(prefix, "bin", "uv");
  const toolDir = join(prefix, "uv-tools");
  const toolBinDir = join(prefix, "uv-tools", "bin");

  const proc = Bun.spawn([uv, "tool", "install", "ty"], {
    stdout: "inherit",
    stderr: "inherit",
    env: {
      ...process.env,
      ...buildUvEnv(prefix),
      PATH: `${join(prefix, "bin")}:${process.env.PATH}`,
      UV_TOOL_DIR: toolDir,
      UV_TOOL_BIN_DIR: toolBinDir,
    },
  });
  const exitCode = await proc.exited;
  if (exitCode !== 0) throw new Error(`uv tool install failed (${exitCode})`);
  console.log("  ty installed successfully.");
}
